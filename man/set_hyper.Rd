% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/set_hyper_init.R
\name{set_hyper}
\alias{set_hyper}
\title{Gather model hyperparameters provided by the user.}
\usage{
set_hyper(
  d,
  p,
  lambda,
  nu,
  a,
  b,
  eta,
  kappa,
  r = NULL,
  m0 = NULL,
  n0 = NULL,
  s02 = NULL,
  s2 = NULL,
  t02 = NULL,
  G = NULL
)
}
\arguments{
\item{d}{Number of responses.}

\item{p}{Number of candidate predictors.}

\item{lambda}{Vector of length 1 providing the values of hyperparameter
\eqn{\lambda} for the prior distribution of \eqn{\sigma^{-2}}. \eqn{\sigma}
represents the typical size of nonzero effects.}

\item{nu}{Vector of length 1 providing the values of hyperparameter \eqn{\nu}
for the prior distribution of \eqn{\sigma^{-2}}. \eqn{\sigma} represents
the typical size of nonzero effects.}

\item{a}{Vector of length 1 or p providing the values of hyperparameter
\eqn{a} for the prior distributions for the proportion of responses
associated with each candidate predictor, \eqn{\omega} (vector of length p).
If of length 1, the provided value is repeated p times.}

\item{b}{Vector of length 1 or p providing the values of hyperparameter
\eqn{b} for the prior distributions for the proportion of responses
associated with each candidate predictor, \eqn{\omega} (vector of length p).
If of length 1, the provided value is repeated p times.}

\item{eta}{Vector of length 1 or d. Provides the values of
hyperparameter \eqn{\eta} for the prior distributions of the continuous
response residual precisions, \eqn{\tau}. If of length 1, the provided
value is repeated d times.}

\item{kappa}{Vector of length 1 or d. Provides the values of hyperparameter
\eqn{\kappa} for the prior distributions of the response residual
precisions, \eqn{\tau}. If of length 1, the provided value is repeated d 
times.}

\item{r}{Number of variables representing external information on the
candidate predictors. Default is \code{NULL}, for \code{V} \code{NULL}.}

\item{m0}{Vector of length 1 or p. Hyperparameter when \code{V}. Default is \code{NULL}.}

\item{n0}{Vector of length 1 or d.}

\item{s02}{Variance hyperparameter when \code{V} is 
non-\code{NULL} non-\code{NULL}. Default is \code{NULL}.}

\item{s2}{Variance hyperparameter when \code{V} is non-\code{NULL}
non-\code{NULL}. Default is \code{NULL}.}

\item{t02}{Variance hyperparameter.}

\item{G}{Number of candidate predictor groups when using the group selection
model from the \code{\link{epispot}} function. Default is \code{NULL},
for no group selection.}
}
\value{
An object of class "\code{hyper}" preparing user hyperparameter in a
  form that can be passed to the \code{\link{epispot}} function.
}
\description{
This function must be used to provide hyperparameter values for the model
used in \code{\link{epispot}}.
}
\details{
The \code{\link{epispot}} function can also be used with default hyperparameter
choices (without using \code{\link{set_hyper}}) by setting its argument
\code{list_hyper} to \code{NULL}.
}
\examples{
seed <- 123; set.seed(seed)

###################
## Simulate data ##
###################

## Examples using small problem sizes:
##
n <- 200; p <- 200; p0 <- 20; d <- 20; d0 <- 15; q <- 2; r <- 3

## Candidate predictors (subject to selection)
##
# Here we simulate common genetic variants (but any type of candidate
# predictors can be supplied).
# 0 = homozygous, major allele, 1 = heterozygous, 2 = homozygous, minor allele

X_act <- matrix(rbinom(n * p0, size = 2, p = 0.25), nrow = n)
X_inact <- matrix(rbinom(n * (p - p0), size = 2, p = 0.25), nrow = n)

shuff_x_ind <- sample(p)
X <- cbind(X_act, X_inact)[, shuff_x_ind]

bool_x_act <- shuff_x_ind <= p0

pat_act <- beta <- matrix(0, nrow = p0, ncol = d0)
pat_act[sample(p0*d0, floor(p0*d0/5))] <- 1
beta[as.logical(pat_act)] <-  rnorm(sum(pat_act))

## Covariates (not subject to selection)
##
Z <- matrix(rnorm(n * q), nrow = n)

alpha <-  matrix(rnorm(q * d), nrow = q)

## Gaussian responses
##
Y_act <- matrix(rnorm(n * d0, mean = X_act \%*\% beta, sd = 0.5), nrow = n)
Y_inact <- matrix(rnorm(n * (d - d0), sd = 0.5), nrow = n)
shuff_y_ind <- sample(d)
Y <- cbind(Y_act, Y_inact)[, shuff_y_ind] + Z \%*\% alpha

## Binary responses
##
Y_bin <- ifelse(Y > 0, 1, 0)
## Informative annotation variables
##
V <- matrix(rnorm(p * r), nrow = p)
V[bool_x_act, ] <- rnorm(p0 * r, mean = 2)

########################
## Infer associations ##
########################

## Continuous responses
##

# No covariate
#
# a and b chosen so that the prior mean number of responses associated with
# each candidate predictor is 1/4.
list_hyper_g <- set_hyper(d, p, lambda = 1, nu = 1, a = 1, b = 4*d-1,
                          eta = 1, kappa = apply(Y, 2, var),
                          link = "identity")

# We take p0_av = p0 (known here); this choice may result in variable
# selections that are (too) conservative in some cases. In practice, it is
# advised to set p0_av as a slightly overestimated guess of p0, or perform
# cross-validation using function `set_cv'.

vb_g <- epispot(Y = Y, X = X, p0_av = p0, link = "identity",
              list_hyper = list_hyper_g, user_seed = seed)

# With covariates
#
list_hyper_g_z <- set_hyper(d, p, lambda = 1, nu = 1, a = 1, b = 4*d-1,
                            eta = 1, kappa = apply(Y, 2, var),
                            link = "identity", q = q, phi = 1, xi = 1)

vb_g_z <- epispot(Y = Y, X = X, p0_av = p0, Z = Z, link = "identity",
                list_hyper = list_hyper_g_z, user_seed = seed)


# With external annotation variables
#
list_hyper_g_v <- set_hyper(d, p, lambda = 1, nu = 1, a = NULL, b = NULL,
                            eta = 1, kappa = apply(Y, 2, var),
                            link = "identity", r = r, m0 = 0, s02 = 0.1,
                            s2 = 0.001)

vb_g_v <- epispot(Y = Y, X = X, p0_av = p0,  V = V, link = "identity",
                list_hyper = list_hyper_g_v, user_seed = seed)

## Binary responses
##
list_hyper_logit <- set_hyper(d, p, lambda = 1, nu = 1, a = 1, b = 4*d-1,
                              eta = NULL, kappa = NULL, link = "logit",
                              q = q, phi = 1, xi = 1)

vb_logit <- epispot(Y = Y_bin, X = X, p0_av = p0, Z = Z, link = "logit",
                  list_hyper = list_hyper_logit, user_seed = seed)

list_hyper_probit <- set_hyper(d, p, lambda = 1, nu = 1, a = 1, b = 4*d-1,
                               eta = NULL, kappa = NULL, link = "probit",
                               q = q, phi = 1, xi = 1)

vb_probit <- epispot(Y = Y_bin, X = X, p0_av = p0, Z = Z, link = "probit",
                   list_hyper = list_hyper_probit, user_seed = seed)


## Mix of continuous and binary responses
##
Y_mix <- cbind(Y, Y_bin)
ind_bin <- (d+1):(2*d)

list_hyper_mix <- set_hyper(2*d, p, lambda = 1, nu = 1, a = 1, b = 8*d-1,
                            eta = 1, kappa = apply(Y, 2, var), link = "mix",
                            ind_bin = ind_bin, q = q, phi = 1, xi = 1)

vb_mix <- epispot(Y = Y_mix, X = X, p0_av = p0, Z = Z, link = "mix",
                ind_bin = ind_bin, list_hyper = list_hyper_mix,
                user_seed = seed)

}
\seealso{
\code{\link{set_init}}, \code{\link{epispot}}
}
