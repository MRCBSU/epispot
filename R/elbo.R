# This file is part of the `epispot` R package:
#     https://github.com/hruffieux/epispot
#
# Internal functions gathering the ELBO terms common to core algorithms.
#

############################################
## E log p(alpha | rest) - E log q(alpha) ##
############################################

e_alpha_ <- function(m2_alpha, log_tau_vb, log_zeta2_inv_vb, sig2_alpha_vb,
                     tau_vb, zeta2_inv_vb) {
  
  1 / 2 * sum(sweep( sweep( sweep( sweep(m2_alpha, 2, tau_vb, `*`), 1,
                                   -zeta2_inv_vb, `*`), 2, log_tau_vb, `+`), 1,
                     log_zeta2_inv_vb , `+`) + log(sig2_alpha_vb) + 1)
  
  
}


e_alpha_logit_ <- function(m2_alpha, log_zeta2_inv_vb, sig2_alpha_vb, zeta2_inv_vb) {
  
  1 / 2 * sum( sweep(-sweep(m2_alpha, 1, zeta2_inv_vb, `*`), 1,
                     log_zeta2_inv_vb, `+`) + log(sig2_alpha_vb) + 1)
  
}


e_alpha_probit_ <- function(m2_alpha, log_zeta2_inv_vb, sig2_alpha_vb, zeta2_inv_vb) {
  
  1 / 2 * sum(sweep(-sweep(m2_alpha, 1, zeta2_inv_vb, `*`), 1,
                    log_zeta2_inv_vb + log(sig2_alpha_vb), `+`) + 1)
  
}


########################################################
## E log p(beta, gamma | rest) - E log q(beta, gamma) ##
########################################################


e_beta_gamma_ <- function(gam_vb, log_om_vb, log_1_min_om_vb, log_sig2_inv_vb,
                          log_tau_vb, m2_beta, sig2_beta_vb, sig2_inv_vb, tau_vb) {
  
  eps <- .Machine$double.eps # to control the argument of the log when gamma is very small
  sum(log_sig2_inv_vb * gam_vb / 2 + sweep(gam_vb, 2, log_tau_vb, `*`) / 2 -
        sweep(m2_beta, 2, tau_vb, `*`) * sig2_inv_vb / 2 +
        sweep(gam_vb, 1, log_om_vb, `*`) +
        sweep(1 - gam_vb, 1, log_1_min_om_vb, `*`) +
        1 / 2 * sweep(gam_vb, 2, log(sig2_beta_vb) + 1, `*`) -
        gam_vb * log(gam_vb + eps) - (1 - gam_vb) * log(1 - gam_vb + eps))
  
}


e_g_beta_gamma_ <- function(gam_vb, g_sizes, log_om_vb, log_1_min_om_vb,
                            log_sig2_inv_vb, log_tau_vb, list_m1_btb,
                            list_sig2_beta_star, sig2_inv_vb, tau_vb, vec_log_det) {
  
  eps <- .Machine$double.eps # to control the argument of the log when gamma is very small
  
  G <- length(list_m1_btb)
  
  sum(unlist(lapply(1:G, function(g) {
    
    sum(g_sizes[g] / 2 * gam_vb[g, ] * (log_sig2_inv_vb + log_tau_vb) -
          list_m1_btb[[g]] * tau_vb * sig2_inv_vb / 2 +
          gam_vb[g, ] * log_om_vb[g] + (1 - gam_vb[g, ]) * log_1_min_om_vb[g] +
          1 / 2 * gam_vb[g, ] * (vec_log_det[g] - g_sizes[g] * (log(tau_vb) - 1)) -
          gam_vb[g, ] * log(gam_vb[g, ] + eps) - (1 - gam_vb[g, ]) * log(1 - gam_vb[g, ] + eps))
  })))
  
}

e_dual_g_beta_gamma_ <- function(gam_vb, g_sizes, log_1_min_Phi_mat, log_Phi_mat, 
                                 log_sig2_inv_vb, log_tau_vb, list_m1_btb,
                                 list_sig2_beta_star, sig2_inv_vb, tau_vb, vec_log_det) {
  
  eps <- .Machine$double.eps # to control the argument of the log when gamma is very small
  
  G <- length(list_m1_btb)
  
  sum(unlist(lapply(1:G, function(g) {
    
    sum(g_sizes[g] / 2 * gam_vb[g, ] * (log_sig2_inv_vb + log_tau_vb) -
          list_m1_btb[[g]] * tau_vb * sig2_inv_vb / 2 +
          gam_vb[g, ] * log_Phi_mat[g, ] + (1 - gam_vb[g, ]) * log_1_min_Phi_mat[g, ] +
          1 / 2 * gam_vb[g, ] * (vec_log_det[g] - g_sizes[g] * (log(tau_vb) - 1)) -
          gam_vb[g, ] * log(gam_vb[g, ] + eps) - (1 - gam_vb[g, ]) * log(1 - gam_vb[g, ] + eps))
  })))
  
}


e_beta_gamma_bin_ <- function(gam_vb, log_om_vb, log_1_min_om_vb, log_sig2_inv_vb,
                              m2_beta, sig2_beta_vb, sig2_inv_vb) {
  
  eps <- .Machine$double.eps # to control the argument of the log when gamma is very small
  sum(gam_vb * log_sig2_inv_vb / 2 - m2_beta * sig2_inv_vb / 2 +
        sweep(gam_vb, 1, log_om_vb, `*`) +
        sweep(1 - gam_vb, 1, log_1_min_om_vb, `*`) +
        gam_vb * (log(sig2_beta_vb) + 1) / 2 -
        gam_vb * log(gam_vb + eps) - (1 - gam_vb) * log(1 - gam_vb + eps))
  
}


e_beta_gamma_info_ <- function(V, gam_vb, log_sig2_inv_vb, log_tau_vb, 
                               log_1_min_Phi_mat_v_mu, log_Phi_mat_v_mu,
                               m2_beta, sig2_beta_vb, sig2_c0_vb, sig2_c_vb,
                               sig2_inv_vb, tau_vb) {
  
  eps <- .Machine$double.eps^0.75 # to control the argument of the log when gamma is very small
  
  sum(log_sig2_inv_vb * gam_vb / 2 +
        sweep(gam_vb, 2, log_tau_vb, `*`) / 2 -
        sweep(m2_beta, 2, tau_vb, `*`) * sig2_inv_vb / 2 +
        gam_vb * log_Phi_mat_v_mu +
        sweep((1 - gam_vb) * log_1_min_Phi_mat_v_mu, 1,
              sig2_c_vb * rowSums(V^2) / 2, `-`) -
        sig2_c0_vb / 2 + 1 / 2 * sweep(gam_vb, 2, log(sig2_beta_vb) + 1, `*`) -
        gam_vb * log(gam_vb + eps) - (1 - gam_vb) * log(1 - gam_vb + eps))
  
}


e_beta_gamma_info_bin_ <- function(V, gam_vb, log_sig2_inv_vb, 
                                   log_1_min_Phi_mat_v_mu, log_Phi_mat_v_mu, m2_beta,
                                   sig2_beta_vb, sig2_c0_vb, sig2_c_vb, sig2_inv_vb) {
  
  eps <- .Machine$double.eps^0.75 # to control the argument of the log when gamma is very small
  
  sum(gam_vb * log_sig2_inv_vb / 2 - m2_beta * sig2_inv_vb / 2 +
        gam_vb * log_Phi_mat_v_mu +
        sweep((1 - gam_vb) * log_1_min_Phi_mat_v_mu, 1, sig2_c_vb * rowSums(V^2) / 2, `-`) -
        sig2_c0_vb / 2 + gam_vb * (log(sig2_beta_vb) + 1) / 2 -
        gam_vb * log(gam_vb + eps) - (1 - gam_vb) * log(1 - gam_vb + eps))
  
}


e_beta_gamma_struct_ <- function(gam_vb, log_sig2_inv_vb, log_tau_vb, 
                                 log_1_min_Phi_mu_theta_vb, log_Phi_mu_theta_vb,
                                 m2_beta, sig2_beta_vb, list_sig2_theta_vb,
                                 sig2_inv_vb, tau_vb) {
  
  eps <- .Machine$double.eps^0.75 # to control the argument of the log when gamma is very small
  
  diag_sig2_theta_vb <- unlist(lapply(list_sig2_theta_vb, diag))
  
  sum(log_sig2_inv_vb * gam_vb / 2 +
        sweep(gam_vb, 2, log_tau_vb, `*`) / 2 -
        sweep(m2_beta, 2, tau_vb, `*`) * sig2_inv_vb / 2 +
        sweep(gam_vb, 1, log_Phi_mu_theta_vb, `*`) +
        sweep(sweep((1 - gam_vb), 1, log_1_min_Phi_mu_theta_vb, `*`), 1, diag_sig2_theta_vb / 2, `-`) +
        1 / 2 * sweep(gam_vb, 2, log(sig2_beta_vb) + 1, `*`) -
        gam_vb * log(gam_vb + eps) - (1 - gam_vb) * log(1 - gam_vb + eps))
  
}


e_beta_gamma_dual_ <- function(gam_vb, log_sig2_inv_vb, log_tau_vb,
                               log_1_min_Phi_theta_plus_rho, log_Phi_theta_plus_rho,
                               m2_beta, sig2_beta_vb, sig2_rho_vb,
                               list_sig2_theta_vb, sig2_inv_vb, tau_vb) {
  
  eps <- .Machine$double.eps^0.75 # to control the argument of the log when gamma is very small
  
  arg <- log_sig2_inv_vb * gam_vb / 2 +
    sweep(gam_vb, 2, log_tau_vb, `*`) / 2 -
    sweep(m2_beta, 2, tau_vb, `*`) * sig2_inv_vb / 2 +
    gam_vb * log_Phi_theta_plus_rho +
    (1 - gam_vb) * log_1_min_Phi_theta_plus_rho -
    sig2_rho_vb / 2 + 1 / 2 * sweep(gam_vb, 2, log(sig2_beta_vb) + 1, `*`) -
    gam_vb * log(gam_vb + eps) - (1 - gam_vb) * log(1 - gam_vb + eps)
  
  if (is.list(list_sig2_theta_vb)) {
    arg <- sweep(arg, 1, unlist(lapply(list_sig2_theta_vb, diag)) / 2, `-`)
  } else {
    arg <- arg - list_sig2_theta_vb / 2
  }
  
  sum(arg)
  
}


e_beta_gamma_dual_info_ <- function(V, gam_vb, log_sig2_inv_vb, log_tau_vb,
                                    log_1_min_Phi_mat_v_mu, log_Phi_mat_v_mu, 
                                    mu_c_vb, m2_beta, sig2_beta_vb, sig2_c_vb, 
                                    sig2_rho_vb, list_sig2_theta_vb, 
                                    sig2_inv_vb, tau_vb, zeta_vb, 
                                    resp_spec = FALSE, bool_blocks = FALSE,
                                    bool_modules = FALSE, vec_fac_bl_y = NULL,
                                    vec_fac_bl_theta = NULL) {
  
  stopifnot(!(bool_blocks & bool_modules))
  
  eps <- .Machine$double.eps^0.75 # to control the argument of the log when gamma is very small
  
  arg <- log_sig2_inv_vb * gam_vb / 2 +
    sweep(gam_vb, 2, log_tau_vb, `*`) / 2 -
    sweep(m2_beta, 2, tau_vb, `*`) * sig2_inv_vb / 2 +
    gam_vb * log_Phi_mat_v_mu +
    (1 - gam_vb) * log_1_min_Phi_mat_v_mu -
    sig2_rho_vb / 2 + 1 / 2 * sweep(gam_vb, 2, log(sig2_beta_vb) + 1, `*`) -
    gam_vb * log(gam_vb + eps) - (1 - gam_vb) * log(1 - gam_vb + eps)
  
  if (is.list(list_sig2_theta_vb)) {
    
    arg <- sweep(arg, 1, unlist(lapply(list_sig2_theta_vb, diag)) / 2, `-`)
    
  } else if (!is.null(vec_fac_bl_theta)) {
    
    stopifnot(bool_blocks | bool_modules)
    
    if (bool_blocks) {
      
      bl_ids <- as.numeric(levels(vec_fac_bl_theta))
      n_bl <- length(bl_ids)
      
      vec_p_bl <- table(vec_fac_bl_theta)
      
      arg <- sweep(arg, 1, unlist(sapply(1:n_bl, function(bl) list_sig2_theta_vb[vec_fac_bl_theta == bl_ids[bl]])), `-`)
      
    } else { # bool_modules
      
      stopifnot(!is.null(vec_fac_bl_y))
      
      bl_ids_x <- as.numeric(levels(vec_fac_bl_theta))
      n_bl_x <- length(bl_ids_x)
      
      vec_p_bl <- table(vec_fac_bl_theta)
      
      bl_ids_y <- as.numeric(levels(vec_fac_bl_y))
      n_bl_y <- length(bl_ids_y)
      
      for(bl_y in 1:n_bl_y){
        
          arg[, vec_fac_bl_y == bl_ids_y[bl_y]] <- sweep(arg[, vec_fac_bl_y == bl_ids_y[bl_y], drop = FALSE], 1,
                                                         as.vector(unlist(sapply(1:n_bl_x, function(bl_x) list_sig2_theta_vb[vec_fac_bl_theta == bl_ids_x[bl_x], bl_y]))), `-`)
        
      }
    }
    
  } else {
    arg <- arg - list_sig2_theta_vb / 2
  }
  
  if (bool_blocks) {
    
    n_bl <- length(V)
    
    vec_arg <- as.vector(unlist(sapply(1:n_bl, function(bl) {
      V[[bl]]^2 %*% (zeta_vb[[bl]] * (sig2_c_vb[bl] + mu_c_vb[[bl]]^2) - (mu_c_vb[[bl]] * zeta_vb[[bl]])^2) / 2})))
    arg <- sweep(arg, 1, vec_arg, `-`)
    
  } else if (bool_modules) {
    
    n_bl_x <- length(V)
    
    bl_ids_y <- as.numeric(levels(vec_fac_bl_y))
    n_bl_y <- length(bl_ids_y)
    
    for(bl_y in 1:n_bl_y){
      
      vec_arg <- as.vector(unlist(sapply(1:n_bl_x, function(bl_x) {
        
        V[[bl_x]]^2 %*% (zeta_vb[[bl_x]][, bl_y] * (sig2_c_vb[bl_x, bl_y] + mu_c_vb[[bl_x]][, bl_y]^2) - (mu_c_vb[[bl_x]][, bl_y] * zeta_vb[[bl_x]][, bl_y])^2) / 2
      })))
      
      arg[, vec_fac_bl_y == bl_ids_y[bl_y]] <- sweep(arg[, vec_fac_bl_y == bl_ids_y[bl_y], drop = FALSE], 1, vec_arg, `-`)
    }
    
    
  } else {
    
    m1_c <- mu_c_vb * zeta_vb
    m2_c <- zeta_vb * (sig2_c_vb + mu_c_vb^2)
    
    if (resp_spec) {
      arg <- arg - V^2 %*% (m2_c - m1_c^2) / 2
    } else {
      arg <- sweep(arg, 1, V^2 %*% (m2_c - m1_c^2) / 2, `-`)
    }
    
  }
  
  sum(arg)
  
}


######################################
## E log p(c0 | rest) - E log q(c0) ##
######################################

e_c0_ <- function(m0, mu_c0_vb, s02, sig2_c0_vb) {
  
  sum(log(sig2_c0_vb) + 1 - log(s02) -
        (mu_c0_vb^2 + sig2_c0_vb - 2*mu_c0_vb * m0 + m0^2) / s02) / 2
  
}


######################################
## E log p(c | rest) - E log q(c) ##
######################################

e_c_ <- function(mu_c_vb, s2, sig2_c_vb) {
  
  sum(log(sig2_c_vb) + 1 - log(s2) - (mu_c_vb^2 + sig2_c_vb) / s2) / 2
  
}


######################################################
## E log p(c, zeta_vb | rest) - E log q(c, zeta_vb) ##
######################################################


e_c_zeta_ <- function(log_om_vb, log_1_min_om_vb, mu_c_vb, s2, sig2_c_vb,
                      zeta_vb, resp_spec = FALSE) {
  
  eps <- .Machine$double.eps^0.25 # to control the argument of the log when gamma is very small
  
  arg <- - log(s2) * zeta_vb / 2  - zeta_vb * (sig2_c_vb + mu_c_vb^2) /(2 * s2) +
    1 / 2 * zeta_vb * (log(sig2_c_vb) + 1) - zeta_vb * log(zeta_vb + eps) -
    (1 - zeta_vb) * log(1 - zeta_vb + eps)
  
  if (resp_spec) {
    arg <- arg + sweep(zeta_vb, 1, log_om_vb, `*`) + sweep((1 - zeta_vb), 1, log_1_min_om_vb, `*`)
  } else {
    arg <- arg + zeta_vb * log_om_vb + (1 - zeta_vb) * log_1_min_om_vb
  }
  
  sum(arg)
}


############################################
## E log p(omega | rest) - E log q(omega) ##
############################################

e_omega_ <- function(a, a_vb, b, b_vb, log_om_vb, log_1_min_om_vb) {
  
  sum((a - a_vb) * log_om_vb + (b - b_vb) * log_1_min_om_vb - lbeta(a, b) + lbeta(a_vb, b_vb))
  
}


############################################
## E log p(rho | rest) - E log q(rho) ##
############################################

e_rho_ <- function(mu_rho_vb, n0, sig2_rho_vb, T0_inv, vec_sum_log_det_rho) {
  
  d <- length(mu_rho_vb)
  (vec_sum_log_det_rho - # vec_sum_log_det_rho = log(det(T0_inv)) + log(det(sig2_rho_vb))
      T0_inv * crossprod(mu_rho_vb - n0) -
      d * T0_inv * sig2_rho_vb + d) / 2 # trace of a product
  
}


##################################################
## E log p(sig2_inv | rest) - E log q(sig2_inv) ##
##################################################

e_sig2_inv_ <- function(lambda, lambda_vb, log_sig2_inv_vb, nu, nu_vb, sig2_inv_vb) {
  
  (lambda - lambda_vb) * log_sig2_inv_vb - (nu - nu_vb) * sig2_inv_vb +
    lambda * log(nu) - lambda_vb * log(nu_vb) - lgamma(lambda) + lgamma(lambda_vb)
  
}


e_sig2_inv_hs_ <- function(a_inv_vb, lambda_s0_vb, log_a_inv_vb, log_S0_inv_vb, nu_s0_vb, S0_inv_vb) {
  
  - 1/2 * log_S0_inv_vb - a_inv_vb * S0_inv_vb + log_a_inv_vb / 2 - lgamma(1 / 2) -
    (lambda_s0_vb - 1) * log_S0_inv_vb + nu_s0_vb * S0_inv_vb - 
    lambda_s0_vb * log(nu_s0_vb) + lgamma(lambda_s0_vb)
  
}


########################################
## E log p(tau | rest) - E log q(tau) ##
########################################

e_tau_ <- function(eta, eta_vb, kappa, kappa_vb, log_tau_vb, tau_vb) {
  
  sum((eta - eta_vb) * log_tau_vb - (kappa - kappa_vb) * tau_vb +
        eta * log(kappa) - eta_vb * log(kappa_vb) - lgamma(eta) + lgamma(eta_vb))
  
}


############################################
## E log p(theta | rest) - E log q(theta) ##
############################################

# S0_inv is assumed to be block-diagonal
e_theta_ <- function(m0, mu_theta_vb, list_S0_inv, list_sig2_theta_vb, 
                     vec_sum_log_det, vec_fac_bl = NULL, vec_fac_bl_y = NULL) {
  
    p <- length(mu_theta_vb)
    
    if (is.null(vec_fac_bl)) {

        arg <- vec_sum_log_det / 2 - # vec_sum_log_det[bl] = log(det(S0_inv_bl)) + log(det(sig2_theta_vb_bl))
          sum(list_S0_inv * (mu_theta_vb - m0)^2 +
                list_S0_inv * list_sig2_theta_vb) / 2 + p / 2 # trace of a product
    
    } else if (!is.null(vec_fac_bl_y)){
      
      bl_ids_x <- as.numeric(levels(vec_fac_bl))
      n_bl_x <- length(bl_ids_x)
      
      vec_p_bl <- table(vec_fac_bl)
      
      bl_ids_y <- as.numeric(levels(vec_fac_bl_y))
      n_bl_y <- length(bl_ids_y)
      
        arg <-  sapply(1:n_bl_y, function(bl_y) {
          
          sapply(1:n_bl_x, function(bl_x) {
            
            vec_sum_log_det[bl_x, bl_y] / 2 - 
              sum(list_S0_inv[vec_fac_bl == bl_ids_x[bl_x], bl_y] * (mu_theta_vb[vec_fac_bl == bl_ids_x[bl_x], bl_y] - m0[vec_fac_bl == bl_ids_x[bl_x]])^2 +
                    list_S0_inv[vec_fac_bl == bl_ids_x[bl_x], bl_y] * list_sig2_theta_vb[vec_fac_bl == bl_ids_x[bl_x], bl_y] ) / 2 + vec_p_bl[bl_x] / 2 # trace of a product
            
          }) 
        })
        
    } else {
      
      bl_ids <- as.numeric(levels(vec_fac_bl))
      n_bl <- length(bl_ids)
      
      vec_p_bl <- table(vec_fac_bl)
      
      arg <- sapply(1:n_bl, function(bl) {
        vec_sum_log_det[bl] / 2 - # vec_sum_log_det[bl] = log(det(S0_inv_bl)) + log(det(sig2_theta_vb_bl))
          sum(list_S0_inv[vec_fac_bl == bl_ids[bl]] * (mu_theta_vb[vec_fac_bl == bl_ids[bl]] - m0[vec_fac_bl == bl_ids[bl]])^2 +
                list_S0_inv[vec_fac_bl == bl_ids[bl]] * list_sig2_theta_vb[vec_fac_bl == bl_ids[bl]]) / 2 + vec_p_bl[bl] / 2 # trace of a product
        
      })
    
    }
  
  sum(arg)
  
}


#######################
## E log p(y | rest) ##
#######################

e_y_ <- function(n, kappa, kappa_vb, log_tau_vb, m2_beta, sig2_inv_vb, tau_vb,
                 m2_alpha = NULL, zeta2_inv_vb = NULL) {
  
  arg <- -n / 2 * log(2 * pi) + n / 2 * log_tau_vb - tau_vb *
    (kappa_vb - colSums(m2_beta) * sig2_inv_vb / 2 - kappa)
  
  if (!is.null(m2_alpha))
    arg <- arg + tau_vb * crossprod(m2_alpha, zeta2_inv_vb) / 2
  
  sum(arg)
  
}

e_g_y_ <- function(n, kappa, kappa_vb, list_m1_btb, log_tau_vb, sig2_inv_vb, tau_vb) {
  
  sum(-n / 2 * log(2 * pi) + n / 2 * log_tau_vb - tau_vb *
        (kappa_vb - Reduce(`+`, list_m1_btb) * sig2_inv_vb / 2 - kappa))
  
}


e_y_logit_ <- function(X, Y, Z, chi_vb, m1_beta, m2_alpha, m2_beta, mat_x_m1,
                       mat_z_mu, mu_alpha_vb, psi_vb) {
  
  sum(log_sigmoid_(chi_vb) + Y * (mat_x_m1 + mat_z_mu)  -  chi_vb / 2 -
        psi_vb * (X^2 %*% m2_beta + mat_x_m1^2 - X^2 %*% m1_beta^2 +
                    Z^2 %*% m2_alpha + mat_z_mu^2 - Z^2 %*% mu_alpha_vb^2 +
                    2 * mat_x_m1 * mat_z_mu - chi_vb^2))
  
}


e_y_probit_ <- function(X, Y, Z, m1_beta, m2_beta, mat_x_m1, mat_z_mu,
                        sig2_alpha_vb, sweep = TRUE) {
  
  U <- mat_x_m1 + mat_z_mu
  
  arg <- Y * pnorm(U, log.p = TRUE) +
    (1 - Y) * pnorm(U, lower.tail = FALSE, log.p = TRUE) -
    X^2 %*% (m2_beta - m1_beta^2) / 2
  
  if (sweep)
    arg <- sweep(arg, 1, Z^2 %*% sig2_alpha_vb / 2, `-`)
  else
    arg <- arg - Z^2 %*% sig2_alpha_vb / 2
  
  sum(arg)
  
}


####################################################
## E log p(zeta2_inv | rest) - E log q(zeta2_inv) ##
####################################################

e_zeta2_inv_ <- function(log_zeta2_inv_vb, phi, phi_vb, xi, xi_vb, zeta2_inv_vb) {
  
  sum((phi - phi_vb) * log_zeta2_inv_vb - (xi - xi_vb) * zeta2_inv_vb +
        phi * log(xi) - phi_vb * log(xi_vb) - lgamma(phi) + lgamma(phi_vb))
  
}
